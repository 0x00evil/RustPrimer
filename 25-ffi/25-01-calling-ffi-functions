# 调用ffi函数

> 下文提到的ffi皆指cffi。

**Rust**作为一门**系统**级语言，自带对ffi调用的支持。

## Get Start
### 引入libc库

由于cffi的数据类型与rust不完全相同，我们需要引入libc库来表达对应ffi函数中的类型。

在`Cargo.toml`中添加以下行:

```
[dependencies]
libc = "0.2.9"
```

在你的rs文件中引入库:
```
extern crate libc
```

在以前libc库是和rust一起发布的，后来libc被移入了`crates.io`通过cargo安装。

### 声明你的ffi函数

就像c语言需要include声明了对应函数的头文件一样，rust中调用ffi也需要对对应函数进行声明。

```
use libc::c_int;
use libc::c_void;
use libc::size_t;

#[link(name = "yourlib")]
extern {
    fn your_func(arg1: c_int, arg2: *mut c_void) -> size_t; // 声明ffi函数
    fn your_func2(arg1: c_int, arg2: *mut c_void) -> size_t;
    static ffi_global: c_int; // 声明ffi全局变量
}
```

声明一个ffi库需要一个标记有`#[link(name = "yourlib")]`的`extern`块。`name`为对应的库(so/dll/dylib)的名字。
如：如果你需要`snappy`库(libsnappy.so/libsnappy.dll/libsnappy.dylib), 则对应的`name`为`snappy`。
在一个extern块中你可以声明任意多的函数和变量。

### 调用ffi函数

声明完成后就可以进行调用了。
由于此函数来自外部的c库，所以rust并不能保证该函数的安全性。因此，调用任何一个ffi函数需要一个unsafe块。
```
let result: size_t = unsafe {
    your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void)
};
```

### 封装unsafe，暴露安全接口

作为一个库作者，对外暴露不安全接口是一种非常不合格的做法。在做c库的rust binding时，我们做的最多的将是将不安全的c接口封装成一个安全接口。
通常做法是：在一个叫ffi.rs之类的文件中写上所有的extern块用以声明ffi函数。在一个叫wrapper.rs之类的文件中进行包装：
```
fn your_func_wrapper(arg1: i32, arg2: &mut i32) -> isize {
    unsafe { your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void) } as isize
}
```
对外暴露(pub use) your_func_wrapper 即可。

## 数据结构对应
libc为我们提供了很多原始数据类型，比如c_int, c_float等，但是对于自定义类型，如结构体，则需要我们自行定义。
### 结构体
rust中结构体默认的内存表示和c并不兼容。如果要将结构体传给ffi函数，请为rust的结构体打上标记：
```
#[repr(C)]
struct RustObject {
    a: c_int,
    // other members
}
```
此外，如果使用`#[repr(C, packed)]`将不为此结构体填充空位以对齐。
### Union
比较遗憾的是，rust到目前为止(2016-03-31)还没有一个很好的应对c的union的方法。只能通过一些hack来实现。([https://github.com/rust-lang/rfcs/pull/1444](rfc))
### Enum
和rust一样，添加`#[repr(C)]`标记即可。
### 回调函数
和c库打交道时，我们经常会遇到一个函数接受一个回调函数的情况。将一个rust函数转变成c可执行的回调函数非常简单：在函数前面加上`extern "C"`即可
```rust
extern "C" fn callback(a: c_int) { // 这个函数是传给c调用的
    println!("hello {}!", a);
}

#[link(name = "yourlib")]
extern {
   fn run_callback(data: i32, cb: extern fn(i32));
}

fn main() {
    unsafe {
        run_callback(1 as i32, callback); // 打印 1
    }
}
```
对应c库代码:
```c
typedef void (*rust_callback)(int32_t);

void run_callback(int32_t data, rust_callback callback) {
    callback(data); // 调用传过来的回调函数
}
```
### 字符串
rust为了应对不同的情况，有很多种字符串类型。其中`CStr`和`CString`是专用于ffi交互的。
#### CStr
对于产生于c的字符串(如在c程序中进行的malloc)，rust使用`CStr`来表示，和`str`类型对应，表明我们并不拥有这个字符串。
```
### 透明结构体
## 内存安全
### 析构问题
### 空指针优化
### ownership处理
### panic
## 静态库/动态库
## 调用约定
## bindgen
