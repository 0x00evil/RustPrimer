# Send 和 Sync

`std::marker` 模块中，有两个 trait：`Send` 和 `Sync`，它们与多线程安全相关。

标记为 `marker trait` 的 trait，它们没有方法，也没有关联 item。它们仅仅包含一种特征，实现了它们的类型必须满足这种特征（或者说因为实现了它们，而满足这种特征，限制了类型的行为）。

`Send` 和 `Sync` 在大部分情况下（针对 Rust 的基础类型和 std 中的大部分类型），会由编译器自动推导出来。对于不能由编译器自动推导出来的类型，要使它们具有 `Send` 或 `Sync` 的特征，可以由人手动实现。实现的时候，必须使用 `unsafe` 前缀，因为 Rust 默认不信任程序员，由程序员自己控制的东西，统统标记为 `unsafe`，由程序员自行负责。

它们的定义如下：

1. 如果 `T: Send`，那么将 `T` 传到另一个线程中时，是按值传送，不会导致数据竞争（或其它不安全情况）。反过来也成立；
2. 如果 `T: Sync`，那么将 `&T` 传到另一个线程中时，不会导致数据竞争（或其它不安全情况），因为 `T: Sync` 意味着 `&T: Send`。反过来也成立；

说明和推论：

1. `Send` 约束的是当一个类型跨越线程边界的时候的行为；
2. `Sync` 约束的是一个类型在多线程中共享时的行为；
3. `Sync + Copy = Send`；
4. 当 `T: Send` 时，可推导出 `&mut T: Send`；
4. 当 `T: Sync` 时，可推导出 `&mut T: Sync`；
5. 当 `&mut T: Send` 时，不能推导出 `T: Send`；

（注：`T`, `&T`, `&mut T`，`Box<T>` 等都是不同的类型）


具体的类型：

1. 原始类型（比如： u8, f64），都是 `Sync`，都是 `Copy`，因此都是 `Send`；
2. 只包含原始类型的复合类型，都是 `Sync`，都是 `Copy`，因此都是 `Send`；
3. 当 `T: Sync`，`Box<T>`, `Vec<T>` 等集合类型是 `Sync`；
4. 具有内部可变性的的指针，不是 `Sync` 的，比如 `Cell`, `RefCell`, `UnsafeCell`；
5. `Rc` 不是 `Sync`。因为只要一做 `&Rc<T>` 操作，就会克隆一个新引用，它会以非原子性的方式修改引用计数，所以是不安全的；
6. 被 `Mutex` 和 `RWLock` 锁住的类型，是 `Sync` 的；
7. 原始指针（`*mut`, `*const`）既不是 `Send` 也不是 `Sync`；


Rust 正是通过这两大武器：`所有权和生命周期` + `Send 和 Sync`（本质上为类型系统）来为并发编程提供了安全可靠的基础设施。使得程序员可以放心在其上构建稳健的并发模型。这也正是 Rust 的核心设计观的体现：内核只提供最基础的原语，真正的实现能分离出去就分离出去。并发也是如此。


PS：本章以后会提供实例说明。


